{"version":3,"file":"conv_gpu_depthwise.js","sourceRoot":"","sources":["../src/conv_gpu_depthwise.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAGH,OAAO,EAAe,gBAAgB,EAAC,MAAM,cAAc,CAAC;AAE5D,MAAM,OAAO,sBAAsB;IAYjC,YACI,QAAiC,EAAE,OAAO,GAAG,KAAK,EAClD,aAAqB,IAAI,EAAE,kBAAkB,GAAG,KAAK,EACrD,iBAAiB,GAAG,KAAK;QAd7B,kBAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAI3B,mBAAc,GAAG;YACf,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,OAAgB,EAAE;YACvC,EAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,OAAgB,EAAE;YAC1C,EAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,OAAgB,EAAE;YAC5C,EAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAgB,EAAE;SAC1C,CAAC;QAMA,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC;QACrC,IAAI,CAAC,mBAAmB,GAAG,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAErE,MAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;QAC3C,MAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,CAAC;QACzC,MAAM,UAAU,GAAG,QAAQ,CAAC,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC;QAE9D,IAAI,iBAAiB,GAAG,EAAE,EAAE,sBAAsB,GAAG,EAAE,CAAC;QACxD,IAAI,UAAU,EAAE;YACd,IAAI,kBAAkB,EAAE;gBACtB,iBAAiB,GAAG;;YAEhB,UAAU;UACZ,CAAC;aACJ;iBAAM,IAAI,iBAAiB,EAAE;gBAC5B,iBAAiB,GAAG;;YAEhB,UAAU;UACZ,CAAC;aACJ;iBAAM;gBACL,iBAAiB,GAAG;;cAEd,UAAU;;SAEf,CAAC;aACH;YAED,sBAAsB,GAAG,8BAA8B,CAAC;SACzD;QAED,MAAM,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,iCAAiC,CAAC,CAAC,CAAC,EAAE,CAAC;QACxE,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACjC;QAED,IAAI,kBAAkB,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;SACnD;QACD,IAAI,iBAAiB,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,QAAQ,GAAG;QACZ,iBAAiB;;;;;;;wBAOD,UAAU;4BACN,UAAU;;;;;;;;;gCASN,YAAY;;;;;;;kCAOV,WAAW;;;;;;;;;;;;;;UAcnC,cAAc;UACd,sBAAsB;;;KAG3B,CAAC;IACJ,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class DepthwiseConv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  customUniforms = [\n    {name: 'pads', type: 'ivec2' as const },\n    {name: 'strides', type: 'ivec2' as const },\n    {name: 'dilations', type: 'ivec2' as const },\n    {name: 'inDims', type: 'ivec2' as const },\n  ];\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n"]}