/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// We use the pattern below (as opposed to require('jasmine') to create the
// jasmine module in order to avoid loading node specific modules which may
// be ignored in browser environments but cannot be ignored in react-native
// due to the pre-bundling of dependencies that it must do.
// tslint:disable-next-line:no-require-imports
const jasmineRequire = require('jasmine-core/lib/jasmine-core/jasmine.js');
const jasmineCore = jasmineRequire.core(jasmineRequire);
import { KernelBackend } from './backends/backend';
import { ENGINE } from './engine';
import { env } from './environment';
Error.stackTraceLimit = Infinity;
jasmineCore.DEFAULT_TIMEOUT_INTERVAL = 20000;
export const NODE_ENVS = {
    predicate: () => env().platformName === 'node'
};
export const CHROME_ENVS = {
    flags: { 'IS_CHROME': true }
};
export const BROWSER_ENVS = {
    predicate: () => env().platformName === 'browser'
};
export const SYNC_BACKEND_ENVS = {
    predicate: (testEnv) => testEnv.isDataSync === true
};
export const HAS_WORKER = {
    predicate: () => typeof (Worker) !== 'undefined' &&
        typeof (Blob) !== 'undefined' && typeof (URL) !== 'undefined'
};
export const HAS_NODE_WORKER = {
    predicate: () => {
        let hasWorker = true;
        try {
            require.resolve('worker_threads');
        }
        catch (_a) {
            hasWorker = false;
        }
        return typeof (process) !== 'undefined' && hasWorker;
    }
};
export const ALL_ENVS = {};
// Tests whether the current environment satisfies the set of constraints.
export function envSatisfiesConstraints(env, testEnv, constraints) {
    if (constraints == null) {
        return true;
    }
    if (constraints.flags != null) {
        for (const flagName in constraints.flags) {
            const flagValue = constraints.flags[flagName];
            if (env.get(flagName) !== flagValue) {
                return false;
            }
        }
    }
    if (constraints.predicate != null && !constraints.predicate(testEnv)) {
        return false;
    }
    return true;
}
/**
 * Add test filtering logic to Jasmine's specFilter hook.
 *
 * @param testFilters Used for include a test suite, with the ability
 *     to selectively exclude some of the tests.
 *     Either `include` or `startsWith` must exist for a `TestFilter`.
 *     Tests that have the substrings specified by the include or startsWith
 *     will be included in the test run, unless one of the substrings specified
 *     by `excludes` appears in the name.
 * @param customInclude Function to programatically include a test.
 *     If this function returns true, a test will immediately run. Otherwise,
 *     `testFilters` is used for fine-grained filtering.
 *
 * If a test is not handled by `testFilters` or `customInclude`, the test will
 * be excluded in the test run.
 */
export function setupTestFilters(testFilters, customInclude) {
    const env = jasmine.getEnv();
    // Account for --grep flag passed to karma by saving the existing specFilter.
    const grepFilter = env.specFilter;
    /**
     * Filter method that returns boolean, if a given test should run or be
     * ignored based on its name. The exclude list has priority over the
     * include list. Thus, if a test matches both the exclude and the include
     * list, it will be exluded.
     */
    // tslint:disable-next-line: no-any
    env.specFilter = (spec) => {
        // Filter out tests if the --grep flag is passed.
        if (!grepFilter(spec)) {
            return false;
        }
        const name = spec.getFullName();
        if (customInclude(name)) {
            return true;
        }
        // Include tests of a test suite unless tests are in excludes list.
        for (let i = 0; i < testFilters.length; ++i) {
            const testFilter = testFilters[i];
            if ((testFilter.include != null &&
                name.indexOf(testFilter.include) > -1) ||
                (testFilter.startsWith != null &&
                    name.startsWith(testFilter.startsWith))) {
                if (testFilter.excludes != null) {
                    for (let j = 0; j < testFilter.excludes.length; j++) {
                        if (name.indexOf(testFilter.excludes[j]) > -1) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
        // Otherwise ignore the test.
        return false;
    };
}
export function parseTestEnvFromKarmaFlags(args, registeredTestEnvs) {
    let flags;
    let testEnvName;
    args.forEach((arg, i) => {
        if (arg === '--flags') {
            flags = JSON.parse(args[i + 1]);
        }
        else if (arg === '--testEnv') {
            testEnvName = args[i + 1];
        }
    });
    const testEnvNames = registeredTestEnvs.map(env => env.name).join(', ');
    if (flags != null && testEnvName == null) {
        throw new Error('--testEnv flag is required when --flags is present. ' +
            `Available values are [${testEnvNames}].`);
    }
    if (testEnvName == null) {
        return null;
    }
    let testEnv;
    registeredTestEnvs.forEach(env => {
        if (env.name === testEnvName) {
            testEnv = env;
        }
    });
    if (testEnv == null) {
        throw new Error(`Test environment with name ${testEnvName} not ` +
            `found. Available test environment names are ` +
            `${testEnvNames}`);
    }
    if (flags != null) {
        testEnv.flags = flags;
    }
    return testEnv;
}
export function describeWithFlags(name, constraints, tests) {
    if (TEST_ENVS.length === 0) {
        throw new Error(`Found no test environments. This is likely due to test environment ` +
            `registries never being imported or test environment registries ` +
            `being registered too late.`);
    }
    TEST_ENVS.forEach(testEnv => {
        env().setFlags(testEnv.flags);
        if (envSatisfiesConstraints(env(), testEnv, constraints)) {
            const testName = name + ' ' + testEnv.name + ' ' + JSON.stringify(testEnv.flags || {});
            executeTests(testName, tests, testEnv);
        }
    });
}
export const TEST_ENVS = [];
// Whether a call to setTestEnvs has been called so we turn off
// registration. This allows command line overriding or programmatic
// overriding of the default registrations.
let testEnvSet = false;
export function setTestEnvs(testEnvs) {
    testEnvSet = true;
    TEST_ENVS.length = 0;
    TEST_ENVS.push(...testEnvs);
}
export function registerTestEnv(testEnv) {
    // When using an explicit call to setTestEnvs, turn off registration of
    // test environments because the explicit call will set the test
    // environments.
    if (testEnvSet) {
        return;
    }
    TEST_ENVS.push(testEnv);
}
function executeTests(testName, tests, testEnv) {
    describe(testName, () => {
        beforeAll(async () => {
            ENGINE.reset();
            if (testEnv.flags != null) {
                env().setFlags(testEnv.flags);
            }
            env().set('IS_TEST', true);
            // Await setting the new backend since it can have async init.
            await ENGINE.setBackend(testEnv.backendName);
        });
        beforeEach(() => {
            ENGINE.startScope();
        });
        afterEach(() => {
            ENGINE.endScope();
            ENGINE.disposeVariables();
        });
        afterAll(() => {
            ENGINE.reset();
        });
        tests(testEnv);
    });
}
export class TestKernelBackend extends KernelBackend {
    dispose() { }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamFzbWluZV91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9qYXNtaW5lX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkRBQTJEO0FBQzNELDhDQUE4QztBQUM5QyxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsMENBQTBDLENBQUMsQ0FBQztBQUMzRSxNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3hELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUNqRCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxHQUFHLEVBQXFCLE1BQU0sZUFBZSxDQUFDO0FBRXRELEtBQUssQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDO0FBQ2pDLFdBQVcsQ0FBQyx3QkFBd0IsR0FBRyxLQUFLLENBQUM7QUFPN0MsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFnQjtJQUNwQyxTQUFTLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxLQUFLLE1BQU07Q0FDL0MsQ0FBQztBQUNGLE1BQU0sQ0FBQyxNQUFNLFdBQVcsR0FBZ0I7SUFDdEMsS0FBSyxFQUFFLEVBQUMsV0FBVyxFQUFFLElBQUksRUFBQztDQUMzQixDQUFDO0FBQ0YsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFnQjtJQUN2QyxTQUFTLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxLQUFLLFNBQVM7Q0FDbEQsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFnQjtJQUM1QyxTQUFTLEVBQUUsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FBQyxPQUFPLENB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LENBQUMsQ0FBQyxDQUFDO1FBRUgsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN0QixDQUFDLENBQUMsQ0FBQztRQUVILFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDYixNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbEIsTUFBTSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ1osTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBRUgsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELE1BQU0sT0FBTyxpQkFBa0IsU0FBUSxhQUFhO0lBQ2xELE9BQU8sS0FBVSxDQUFDO0NBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBXZSB1c2UgdGhlIHBhdHRlcm4gYmVsb3cgKGFzIG9wcG9zZWQgdG8gcmVxdWlyZSgnamFzbWluZScpIHRvIGNyZWF0ZSB0aGVcbi8vIGphc21pbmUgbW9kdWxlIGluIG9yZGVyIHRvIGF2b2lkIGxvYWRpbmcgbm9kZSBzcGVjaWZpYyBtb2R1bGVzIHdoaWNoIG1heVxuLy8gYmUgaWdub3JlZCBpbiBicm93c2VyIGVudmlyb25tZW50cyBidXQgY2Fubm90IGJlIGlnbm9yZWQgaW4gcmVhY3QtbmF0aXZlXG4vLyBkdWUgdG8gdGhlIHByZS1idW5kbGluZyBvZiBkZXBlbmRlbmNpZXMgdGhhdCBpdCBtdXN0IGRvLlxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgamFzbWluZVJlcXVpcmUgPSByZXF1aXJlKCdqYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9qYXNtaW5lLmpzJyk7XG5jb25zdCBqYXNtaW5lQ29yZSA9IGphc21pbmVSZXF1aXJlLmNvcmUoamFzbWluZVJlcXVpcmUpO1xuaW1wb3J0IHtLZXJuZWxCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmRzL2JhY2tlbmQnO1xuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4vZW5naW5lJztcbmltcG9ydCB7ZW52LCBFbnZpcm9ubWVudCwgRmxhZ3N9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuXG5FcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcbmphc21pbmVDb3JlLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IDIwMDAwO1xuXG5leHBvcnQgdHlwZSBDb25zdHJhaW50cyA9IHtcbiAgZmxhZ3M/OiBGbGFncyxcbiAgcHJlZGljYXRlPzogKHRlc3RFbnY6IFRlc3RFbnYpID0+IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgY29uc3QgTk9ERV9FTlZTOiBDb25zdHJhaW50cyA9IHtcbiAgcHJlZGljYXRlOiAoKSA9PiBlbnYoKS5wbGF0Zm9ybU5hbWUgPT09ICdub2RlJ1xufTtcbmV4cG9ydCBjb25zdCBDSFJPTUVfRU5WUzogQ29uc3RyYWludHMgPSB7XG4gIGZsYWdzOiB7J0lTX0NIUk9NRSc6IHRydWV9XG59O1xuZXhwb3J0IGNvbnN0IEJST1dTRVJfRU5WUzogQ29uc3RyYWludHMgPSB7XG4gIHByZWRpY2F0ZTogKCkgPT4gZW52KCkucGxhdGZvcm1OYW1lID09PSAnYnJvd3Nlcidcbn07XG5cbmV4cG9ydCBjb25zdCBTWU5DX0JBQ0tFTkRfRU5WUzogQ29uc3RyYWludHMgPSB7XG4gIHByZWRpY2F0ZTogKHRlc3RFbnY6IFRlc3RFbnYpID0+IHRlc3RFbnYuaXNEYXRhU3luYyA9PT0gdHJ1ZVxufTtcblxuZXhwb3J0IGNvbnN0IEhBU19XT1JLRVIgPSB7XG4gIHByZWRpY2F0ZTogKCkgPT4gdHlwZW9mIChXb3JrZXIpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIChCbG9iKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIChVUkwpICE9PSAndW5kZWZpbmVkJ1xufTtcblxuZXhwb3J0IGNvbnN0IEhBU19OT0RFX1dPUktFUiA9IHtcbiAgcHJlZGljYXRlOiAoKSA9PiB7XG4gICAgbGV0IGhhc1dvcmtlciA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnd29ya2VyX3RocmVhZHMnKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGhhc1dvcmtlciA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIChwcm9jZXNzKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzV29ya2VyO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgQUxMX0VOVlM6IENvbnN0cmFpbnRzID0ge307XG5cbi8vIFRlc3RzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgc2F0aXNmaWVzIHRoZSBzZXQgb2YgY29uc3RyYWludHMuXG5leHBvcnQgZnVuY3Rpb24gZW52U2F0aXNmaWVzQ29uc3RyYWludHMoXG4gICAgZW52OiBFbnZpcm9ubWVudCwgdGVzdEVudjogVGVzdEVudiwgY29uc3RyYWludHM6IENvbnN0cmFpbnRzKTogYm9vbGVhbiB7XG4gIGlmIChjb25zdHJhaW50cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoY29uc3RyYWludHMuZmxhZ3MgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgZmxhZ05hbWUgaW4gY29uc3RyYWludHMuZmxhZ3MpIHtcbiAgICAgIGNvbnN0IGZsYWdWYWx1ZSA9IGNvbnN0cmFpbnRzLmZsYWdzW2ZsYWdOYW1lXTtcbiAgICAgIGlmIChlbnYuZ2V0KGZsYWdOYW1lKSAhPT0gZmxhZ1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnRzLnByZWRpY2F0ZSAhPSBudWxsICYmICFjb25zdHJhaW50cy5wcmVkaWNhdGUodGVzdEVudikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdEZpbHRlciB7XG4gIGluY2x1ZGU/OiBzdHJpbmc7XG4gIHN0YXJ0c1dpdGg/OiBzdHJpbmc7XG4gIGV4Y2x1ZGVzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogQWRkIHRlc3QgZmlsdGVyaW5nIGxvZ2ljIHRvIEphc21pbmUncyBzcGVjRmlsdGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHRlc3RGaWx0ZXJzIFVzZWQgZm9yIGluY2x1ZGUgYSB0ZXN0IHN1aXRlLCB3aXRoIHRoZSBhYmlsaXR5XG4gKiAgICAgdG8gc2VsZWN0aXZlbHkgZXhjbHVkZSBzb21lIG9mIHRoZSB0ZXN0cy5cbiAqICAgICBFaXRoZXIgYGluY2x1ZGVgIG9yIGBzdGFydHNXaXRoYCBtdXN0IGV4aXN0IGZvciBhIGBUZXN0RmlsdGVyYC5cbiAqICAgICBUZXN0cyB0aGF0IGhhdmUgdGhlIHN1YnN0cmluZ3Mgc3BlY2lmaWVkIGJ5IHRoZSBpbmNsdWRlIG9yIHN0YXJ0c1dpdGhcbiAqICAgICB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB0ZXN0IHJ1biwgdW5sZXNzIG9uZSBvZiB0aGUgc3Vic3RyaW5ncyBzcGVjaWZpZWRcbiAqICAgICBieSBgZXhjbHVkZXNgIGFwcGVhcnMgaW4gdGhlIG5hbWUuXG4gKiBAcGFyYW0gY3VzdG9tSW5jbHVkZSBGdW5jdGlvbiB0byBwcm9ncmFtYXRpY2FsbHkgaW5jbHVkZSBhIHRlc3QuXG4gKiAgICAgSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGEgdGVzdCB3aWxsIGltbWVkaWF0ZWx5IHJ1bi4gT3RoZXJ3aXNlLFxuICogICAgIGB0ZXN0RmlsdGVyc2AgaXMgdXNlZCBmb3IgZmluZS1ncmFpbmVkIGZpbHRlcmluZy5cbiAqXG4gKiBJZiBhIHRlc3QgaXMgbm90IGhhbmRsZWQgYnkgYHRlc3RGaWx0ZXJzYCBvciBgY3VzdG9tSW5jbHVkZWAsIHRoZSB0ZXN0IHdpbGxcbiAqIGJlIGV4Y2x1ZGVkIGluIHRoZSB0ZXN0IHJ1bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwVGVzdEZpbHRlcnMoXG4gICAgdGVzdEZpbHRlcnM6IFRlc3RGaWx0ZXJbXSwgY3VzdG9tSW5jbHVkZTogKG5hbWU6IHN0cmluZykgPT4gYm9vbGVhbikge1xuICBjb25zdCBlbnYgPSBqYXNtaW5lLmdldEVudigpO1xuXG4gIC8vIEFjY291bnQgZm9yIC0tZ3JlcCBmbGFnIHBhc3NlZCB0byBrYXJtYSBieSBzYXZpbmcgdGhlIGV4aXN0aW5nIHNwZWNGaWx0ZXIuXG4gIGNvbnN0IGdyZXBGaWx0ZXIgPSBlbnYuc3BlY0ZpbHRlcjtcblxuICAvKipcbiAgICogRmlsdGVyIG1ldGhvZCB0aGF0IHJldHVybnMgYm9vbGVhbiwgaWYgYSBnaXZlbiB0ZXN0IHNob3VsZCBydW4gb3IgYmVcbiAgICogaWdub3JlZCBiYXNlZCBvbiBpdHMgbmFtZS4gVGhlIGV4Y2x1ZGUgbGlzdCBoYXMgcHJpb3JpdHkgb3ZlciB0aGVcbiAgICogaW5jbHVkZSBsaXN0LiBUaHVzLCBpZiBhIHRlc3QgbWF0Y2hlcyBib3RoIHRoZSBleGNsdWRlIGFuZCB0aGUgaW5jbHVkZVxuICAgKiBsaXN0LCBpdCB3aWxsIGJlIGV4bHVkZWQuXG4gICAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICBlbnYuc3BlY0ZpbHRlciA9IChzcGVjOiBhbnkpID0+IHtcbiAgICAvLyBGaWx0ZXIgb3V0IHRlc3RzIGlmIHRoZSAtLWdyZXAgZmxhZyBpcyBwYXNzZWQuXG4gICAgaWYgKCFncmVwRmlsdGVyKHNwZWMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHNwZWMuZ2V0RnVsbE5hbWUoKTtcblxuICAgIGlmIChjdXN0b21JbmNsdWRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJbmNsdWRlIHRlc3RzIG9mIGEgdGVzdCBzdWl0ZSB1bmxlc3MgdGVzdHMgYXJlIGluIGV4Y2x1ZGVzIGxpc3QuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0RmlsdGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdGVzdEZpbHRlciA9IHRlc3RGaWx0ZXJzW2ldO1xuICAgICAgaWYgKCh0ZXN0RmlsdGVyLmluY2x1ZGUgIT0gbnVsbCAmJlxuICAgICAgICAgICBuYW1lLmluZGV4T2YodGVzdEZpbHRlci5pbmNsdWRlKSA+IC0xKSB8fFxuICAgICAgICAgICh0ZXN0RmlsdGVyLnN0YXJ0c1dpdGggIT0gbnVsbCAmJlxuICAgICAgICAgICBuYW1lLnN0YXJ0c1dpdGgodGVzdEZpbHRlci5zdGFydHNXaXRoKSkpIHtcbiAgICAgICAgaWYgKHRlc3RGaWx0ZXIuZXhjbHVkZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdEZpbHRlci5leGNsdWRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZih0ZXN0RmlsdGVyLmV4Y2x1ZGVzW2pdKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIGlnbm9yZSB0aGUgdGVzdC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRlc3RFbnZGcm9tS2FybWFGbGFncyhcbiAgICBhcmdzOiBzdHJpbmdbXSwgcmVnaXN0ZXJlZFRlc3RFbnZzOiBUZXN0RW52W10pOiBUZXN0RW52IHtcbiAgbGV0IGZsYWdzOiBGbGFncztcbiAgbGV0IHRlc3RFbnZOYW1lOiBzdHJpbmc7XG5cbiAgYXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcbiAgICBpZiAoYXJnID09PSAnLS1mbGFncycpIHtcbiAgICAgIGZsYWdzID0gSlNPTi5wYXJzZShhcmdzW2kgKyAxXSk7XG4gICAgfSBlbHNlIGlmIChhcmcgPT09ICctLXRlc3RFbnYnKSB7XG4gICAgICB0ZXN0RW52TmFtZSA9IGFyZ3NbaSArIDFdO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdGVzdEVudk5hbWVzID0gcmVnaXN0ZXJlZFRlc3RFbnZzLm1hcChlbnYgPT4gZW52Lm5hbWUpLmpvaW4oJywgJyk7XG4gIGlmIChmbGFncyAhPSBudWxsICYmIHRlc3RFbnZOYW1lID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICctLXRlc3RFbnYgZmxhZyBpcyByZXF1aXJlZCB3aGVuIC0tZmxhZ3MgaXMgcHJlc2VudC4gJyArXG4gICAgICAgIGBBdmFpbGFibGUgdmFsdWVzIGFyZSBbJHt0ZXN0RW52TmFtZXN9XS5gKTtcbiAgfVxuICBpZiAodGVzdEVudk5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IHRlc3RFbnY6IFRlc3RFbnY7XG4gIHJlZ2lzdGVyZWRUZXN0RW52cy5mb3JFYWNoKGVudiA9PiB7XG4gICAgaWYgKGVudi5uYW1lID09PSB0ZXN0RW52TmFtZSkge1xuICAgICAgdGVzdEVudiA9IGVudjtcbiAgICB9XG4gIH0pO1xuICBpZiAodGVzdEVudiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGVzdCBlbnZpcm9ubWVudCB3aXRoIG5hbWUgJHt0ZXN0RW52TmFtZX0gbm90IGAgK1xuICAgICAgICBgZm91bmQuIEF2YWlsYWJsZSB0ZXN0IGVudmlyb25tZW50IG5hbWVzIGFyZSBgICtcbiAgICAgICAgYCR7dGVzdEVudk5hbWVzfWApO1xuICB9XG4gIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgdGVzdEVudi5mbGFncyA9IGZsYWdzO1xuICB9XG5cbiAgcmV0dXJuIHRlc3RFbnY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZVdpdGhGbGFncyhcbiAgICBuYW1lOiBzdHJpbmcsIGNvbnN0cmFpbnRzOiBDb25zdHJhaW50cywgdGVzdHM6IChlbnY6IFRlc3RFbnYpID0+IHZvaWQpIHtcbiAgaWYgKFRFU1RfRU5WUy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGb3VuZCBubyB0ZXN0IGVudmlyb25tZW50cy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIHRlc3QgZW52aXJvbm1lbnQgYCArXG4gICAgICAgIGByZWdpc3RyaWVzIG5ldmVyIGJlaW5nIGltcG9ydGVkIG9yIHRlc3QgZW52aXJvbm1lbnQgcmVnaXN0cmllcyBgICtcbiAgICAgICAgYGJlaW5nIHJlZ2lzdGVyZWQgdG9vIGxhdGUuYCk7XG4gIH1cblxuICBURVNUX0VOVlMuZm9yRWFjaCh0ZXN0RW52ID0+IHtcbiAgICBlbnYoKS5zZXRGbGFncyh0ZXN0RW52LmZsYWdzKTtcbiAgICBpZiAoZW52U2F0aXNmaWVzQ29uc3RyYWludHMoZW52KCksIHRlc3RFbnYsIGNvbnN0cmFpbnRzKSkge1xuICAgICAgY29uc3QgdGVzdE5hbWUgPVxuICAgICAgICAgIG5hbWUgKyAnICcgKyB0ZXN0RW52Lm5hbWUgKyAnICcgKyBKU09OLnN0cmluZ2lmeSh0ZXN0RW52LmZsYWdzIHx8IHt9KTtcbiAgICAgIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIHRlc3RFbnYpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdEVudiB7XG4gIG5hbWU6IHN0cmluZztcbiAgYmFja2VuZE5hbWU6IHN0cmluZztcbiAgZmxhZ3M/OiBGbGFncztcbiAgaXNEYXRhU3luYz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBURVNUX0VOVlM6IFRlc3RFbnZbXSA9IFtdO1xuXG4vLyBXaGV0aGVyIGEgY2FsbCB0byBzZXRUZXN0RW52cyBoYXMgYmVlbiBjYWxsZWQgc28gd2UgdHVybiBvZmZcbi8vIHJlZ2lzdHJhdGlvbi4gVGhpcyBhbGxvd3MgY29tbWFuZCBsaW5lIG92ZXJyaWRpbmcgb3IgcHJvZ3JhbW1hdGljXG4vLyBvdmVycmlkaW5nIG9mIHRoZSBkZWZhdWx0IHJlZ2lzdHJhdGlvbnMuXG5sZXQgdGVzdEVudlNldCA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRlc3RFbnZzKHRlc3RFbnZzOiBUZXN0RW52W10pIHtcbiAgdGVzdEVudlNldCA9IHRydWU7XG4gIFRFU1RfRU5WUy5sZW5ndGggPSAwO1xuICBURVNUX0VOVlMucHVzaCguLi50ZXN0RW52cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclRlc3RFbnYodGVzdEVudjogVGVzdEVudikge1xuICAvLyBXaGVuIHVzaW5nIGFuIGV4cGxpY2l0IGNhbGwgdG8gc2V0VGVzdEVudnMsIHR1cm4gb2ZmIHJlZ2lzdHJhdGlvbiBvZlxuICAvLyB0ZXN0IGVudmlyb25tZW50cyBiZWNhdXNlIHRoZSBleHBsaWNpdCBjYWxsIHdpbGwgc2V0IHRoZSB0ZXN0XG4gIC8vIGVudmlyb25tZW50cy5cbiAgaWYgKHRlc3RFbnZTZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVEVTVF9FTlZTLnB1c2godGVzdEVudik7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cyhcbiAgICB0ZXN0TmFtZTogc3RyaW5nLCB0ZXN0czogKGVudjogVGVzdEVudikgPT4gdm9pZCwgdGVzdEVudjogVGVzdEVudikge1xuICBkZXNjcmliZSh0ZXN0TmFtZSwgKCkgPT4ge1xuICAgIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gICAgICBFTkdJTkUucmVzZXQoKTtcbiAgICAgIGlmICh0ZXN0RW52LmZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgZW52KCkuc2V0RmxhZ3ModGVzdEVudi5mbGFncyk7XG4gICAgICB9XG4gICAgICBlbnYoKS5zZXQoJ0lTX1RFU1QnLCB0cnVlKTtcbiAgICAgIC8vIEF3YWl0IHNldHRpbmcgdGhlIG5ldyBiYWNrZW5kIHNpbmNlIGl0IGNhbiBoYXZlIGFzeW5jIGluaXQuXG4gICAgICBhd2FpdCBFTkdJTkUuc2V0QmFja2VuZCh0ZXN0RW52LmJhY2tlbmROYW1lKTtcbiAgICB9KTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgRU5HSU5FLnN0YXJ0U2NvcGUoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBFTkdJTkUuZW5kU2NvcGUoKTtcbiAgICAgIEVOR0lORS5kaXNwb3NlVmFyaWFibGVzKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckFsbCgoKSA9PiB7XG4gICAgICBFTkdJTkUucmVzZXQoKTtcbiAgICB9KTtcblxuICAgIHRlc3RzKHRlc3RFbnYpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNsYXNzIFRlc3RLZXJuZWxCYWNrZW5kIGV4dGVuZHMgS2VybmVsQmFja2VuZCB7XG4gIGRpc3Bvc2UoKTogdm9pZCB7fVxufVxuIl19