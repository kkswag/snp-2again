/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../../engine';
import { customGrad } from '../../gradients';
import { FusedDepthwiseConv2D } from '../../kernel_names';
import { makeTypesMatch } from '../../tensor_util';
import { convertToTensor } from '../../tensor_util_env';
import * as util from '../../util';
import { add } from '../add';
import * as broadcast_util from '../broadcast_util';
import * as conv_util from '../conv_util';
import { depthwiseConv2d as unfusedDepthwiseConv2d } from '../depthwise_conv2d';
import { depthwiseConv2dNativeBackpropFilter } from '../depthwise_conv2d_native_backprop_filter';
import { depthwiseConv2dNativeBackpropInput } from '../depthwise_conv2d_native_backprop_input';
import { applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse } from '../fused_util';
import { op } from '../operation';
import { reshape } from '../reshape';
/**
 * Computes depthwise 2D convolution, optionally fused with adding a
 * bias and applying an activation.
 *
 * Given a 4D `input` array and a `filter` array of shape
 * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing
 * `inChannels` convolutional filters of depth 1, this op applies a
 * different filter to each input channel (expanding from 1 channel to
 * `channelMultiplier` channels for each), then concatenates the results
 * together. The output has `inChannels * channelMultiplier` channels.
 *
 * See
 * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](
 *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)
 * for more details.
 *
 * @param obj An object with the following properties:
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter tensor, rank 4, of shape
 *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`. If strides is a single number, then `strideHeight ==
 * strideWidth`.
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels]. Only "NHWC" is currently supported.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @param bias Tensor to be added to the result.
 * @param activation Name of activation kernel (defaults to `linear`).
 * @param preluActivationWeights Tensor of prelu weights to be applied as part
 *     of a `prelu` activation, typically the same shape as `x`.
 * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`
 *     activation.
 */
function fusedDepthwiseConv2d_({ x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
        let result = unfusedDepthwiseConv2d(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
        if (bias != null) {
            result = add(result, bias);
        }
        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, 'x', 'depthwiseConv2d');
    const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    util.assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got ` +
        `rank ${x4D.rank}.`);
    util.assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, ` +
        `but got rank ${$filter.rank}.`);
    util.assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels ` +
        `(${x4D.shape[3]}) must match the inChannels dimension in ` +
        `filter ${$filter.shape[2]}.`);
    if (dilations == null) {
        dilations = [1, 1];
    }
    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in fused depthwiseConv2d: Either strides or dilations must ' +
        `be 1. Got strides ${strides} and dilations '${dilations}'`);
    if (dimRoundingMode != null) {
        util.assert(util.isInt(pad), () => `Error in fused depthwiseConv2d: pad must be an integer when ` +
            `using dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
    }
    const convInfo = conv_util.computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);
    let $bias;
    if (bias != null) {
        $bias = convertToTensor(bias, 'bias', 'fused conv2d');
        [$bias] = makeTypesMatch($bias, $x);
        broadcast_util.assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused depthwiseConv2d');
    }
    const grad = (dy, saved) => {
        util.assert(conv_util.tupleValuesAreOne(dilations), () => 'Error in gradient of fused depthwiseConv2d: dilation rates ' +
            `greater than 1 are not yet supported. Got dilations ` +
            `'${dilations}'`);
        const [$filter, x4D, y, bias] = saved;
        const dyActivation = getFusedDyActivation(dy, y, activation);
        const xDer = depthwiseConv2dNativeBackpropInput(x4D.shape, dyActivation, $filter, strides, pad, dilations, dimRoundingMode);
        const filterDer = depthwiseConv2dNativeBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad, dilations, dimRoundingMode);
        if (bias != null) {
            const biasDer = getFusedBiasGradient($bias, dyActivation);
            return [xDer, filterDer, biasDer];
        }
        return [xDer, filterDer];
    };
    const inputs = {
        x: x4D,
        filter: $filter,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
        strides,
        pad,
        dataFormat,
        dilations,
        dimRoundingMode,
        activation,
        leakyreluAlpha
    };
    // Depending on the the params passed in we will have different number of
    // inputs and thus a a different number of elements in the gradient.
    if (bias == null) {
        const customOp = customGrad((x4D, filter, save) => {
            // tslint:disable-next-line: no-unnecessary-type-assertion
            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
            save([filter, x4D, res]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOp(x4D, $filter);
    }
    else {
        const customOpWithBias = customGrad((x4D, filter, bias, save) => {
            // tslint:disable-next-line: no-unnecessary-type-assertion
            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
            save([filter, x4D, res, bias]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOpWithBias(x4D, $filter, $bias);
    }
}
export const depthwiseConv2d = op({ fusedDepthwiseConv2d_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwdGh3aXNlX2NvbnYyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL2Z1c2VkL2RlcHRod2lzZV9jb252MmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFDLG9CQUFvQixFQUF3RCxNQUFNLG9CQUFvQixDQUFDO0FBSS9HLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxLQUFLLElBQUksTUFBTSxZQUFZLENBQUM7QUFFbkMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUMzQixPQUFPLEtBQUssY0FBYyxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sS0FBSyxTQUFTLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBQyxlQUFlLElBQUksc0JBQXNCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUM5RSxPQUFPLEVBQUMsbUNBQW1DLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUMvRixPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSwyQ0FBMkMsQ0FBQztBQUU3RixPQUFPLEVBQUMsZUFBZSxFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN0RyxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QyxDQUFDO1FBRVAsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBTSxDQUFDO0tBQ25EO0FBQ0gsQ0FBQztBQUNELE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxFQUFFLENBQUMsRUFBQyxxQkFBcUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtjdXN0b21HcmFkfSBmcm9tICcuLi8uLi9ncmFkaWVudHMnO1xuaW1wb3J0IHtGdXNlZERlcHRod2lzZUNvbnYyRCwgRnVzZWREZXB0aHdpc2VDb252MkRBdHRycywgRnVzZWREZXB0aHdpc2VDb252MkRJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4vLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IzRCwgVGVuc29yNER9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0dyYWRTYXZlRnVuYywgTmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge21ha2VUeXBlc01hdGNofSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbCc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHthZGR9IGZyb20gJy4uL2FkZCc7XG5pbXBvcnQgKiBhcyBicm9hZGNhc3RfdXRpbCBmcm9tICcuLi9icm9hZGNhc3RfdXRpbCc7XG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vY29udl91dGlsJztcbmltcG9ydCB7ZGVwdGh3aXNlQ29udjJkIGFzIHVuZnVzZWREZXB0aHdpc2VDb252MmR9IGZyb20gJy4uL2RlcHRod2lzZV9jb252MmQnO1xuaW1wb3J0IHtkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlcn0gZnJvbSAnLi4vZGVwdGh3aXNlX2NvbnYyZF9uYXRpdmVfYmFja3Byb3BfZmlsdGVyJztcbmltcG9ydCB7ZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dH0gZnJvbSAnLi4vZGVwdGh3aXNlX2NvbnYyZF9uYXRpdmVfYmFja3Byb3BfaW5wdXQnO1xuaW1wb3J0IHtBY3RpdmF0aW9ufSBmcm9tICcuLi9mdXNlZF90eXBlcyc7XG5pbXBvcnQge2FwcGx5QWN0aXZhdGlvbiwgZ2V0RnVzZWRCaWFzR3JhZGllbnQsIGdldEZ1c2VkRHlBY3RpdmF0aW9uLCBzaG91bGRGdXNlfSBmcm9tICcuLi9mdXNlZF91dGlsJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4uL3Jlc2hhcGUnO1xuXG4vKipcbiAqIENvbXB1dGVzIGRlcHRod2lzZSAyRCBjb252b2x1dGlvbiwgb3B0aW9uYWxseSBmdXNlZCB3aXRoIGFkZGluZyBhXG4gKiBiaWFzIGFuZCBhcHBseWluZyBhbiBhY3RpdmF0aW9uLlxuICpcbiAqIEdpdmVuIGEgNEQgYGlucHV0YCBhcnJheSBhbmQgYSBgZmlsdGVyYCBhcnJheSBvZiBzaGFwZVxuICogYFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpbkNoYW5uZWxzLCBjaGFubmVsTXVsdGlwbGllcl1gIGNvbnRhaW5pbmdcbiAqIGBpbkNoYW5uZWxzYCBjb252b2x1dGlvbmFsIGZpbHRlcnMgb2YgZGVwdGggMSwgdGhpcyBvcCBhcHBsaWVzIGFcbiAqIGRpZmZlcmVudCBmaWx0ZXIgdG8gZWFjaCBpbnB1dCBjaGFubmVsIChleHBhbmRpbmcgZnJvbSAxIGNoYW5uZWwgdG9cbiAqIGBjaGFubmVsTXVsdGlwbGllcmAgY2hhbm5lbHMgZm9yIGVhY2gpLCB0aGVuIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0c1xuICogdG9nZXRoZXIuIFRoZSBvdXRwdXQgaGFzIGBpbkNoYW5uZWxzICogY2hhbm5lbE11bHRpcGxpZXJgIGNoYW5uZWxzLlxuICpcbiAqIFNlZVxuICogW2h0dHBzOi8vd3d3LnRlbnNvcmZsb3cub3JnL2FwaV9kb2NzL3B5dGhvbi90Zi9ubi9kZXB0aHdpc2VfY29udjJkXShcbiAqICAgICBodHRwczovL3d3dy50ZW5zb3JmbG93Lm9yZy9hcGlfZG9jcy9weXRob24vdGYvbm4vZGVwdGh3aXNlX2NvbnYyZClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIG9iaiBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yLCBvZiByYW5rIDQgb3IgcmFuayAzLCBvZiBzaGFwZVxuICogICAgIGBbYmF0Y2gsIGhlaWdodCwgd2lkdGgsIGluQ2hhbm5lbHNdYC4gSWYgcmFuayAzLCBiYXRjaCBvZiAxIGlzXG4gKiBhc3N1bWVkLlxuICogQHBhcmFtIGZpbHRlciBUaGUgZmlsdGVyIHRlbnNvciwgcmFuayA0LCBvZiBzaGFwZVxuICogICAgIGBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5DaGFubmVscywgY2hhbm5lbE11bHRpcGxpZXJdYC5cbiAqIEBwYXJhbSBzdHJpZGVzIFRoZSBzdHJpZGVzIG9mIHRoZSBjb252b2x1dGlvbjogYFtzdHJpZGVIZWlnaHQsXG4gKiBzdHJpZGVXaWR0aF1gLiBJZiBzdHJpZGVzIGlzIGEgc2luZ2xlIG51bWJlciwgdGhlbiBgc3RyaWRlSGVpZ2h0ID09XG4gKiBzdHJpZGVXaWR0aGAuXG4gKiBAcGFyYW0gcGFkIFRoZSB0eXBlIG9mIHBhZGRpbmcgYWxnb3JpdGhtLlxuICogICAtIGBzYW1lYCBhbmQgc3RyaWRlIDE6IG91dHB1dCB3aWxsIGJlIG9mIHNhbWUgc2l6ZSBhcyBpbnB1dCxcbiAqICAgICAgIHJlZ2FyZGxlc3Mgb2YgZmlsdGVyIHNpemUuXG4gKiAgIC0gYHZhbGlkYDogb3V0cHV0IHdpbGwgYmUgc21hbGxlciB0aGFuIGlucHV0IGlmIGZpbHRlciBpcyBsYXJnZXJcbiAqICAgICAgIHRoYW4gMXgxLlxuICogICAtIEZvciBtb3JlIGluZm8sIHNlZSB0aGlzIGd1aWRlOlxuICogICAgIFtodHRwczovL3d3dy50ZW5zb3JmbG93Lm9yZy9hcGlfZG9jcy9weXRob24vdGYvbm4vY29udm9sdXRpb25dKFxuICogICAgICAgICAgaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL25uL2NvbnZvbHV0aW9uKVxuICogQHBhcmFtIGRpbGF0aW9ucyBUaGUgZGlsYXRpb24gcmF0ZXM6IGBbZGlsYXRpb25IZWlnaHQsIGRpbGF0aW9uV2lkdGhdYFxuICogICAgIGluIHdoaWNoIHdlIHNhbXBsZSBpbnB1dCB2YWx1ZXMgYWNyb3NzIHRoZSBoZWlnaHQgYW5kIHdpZHRoIGRpbWVuc2lvbnNcbiAqICAgICBpbiBhdHJvdXMgY29udm9sdXRpb24uIERlZmF1bHRzIHRvIGBbMSwgMV1gLiBJZiBgcmF0ZWAgaXMgYSBzaW5nbGVcbiAqICAgICBudW1iZXIsIHRoZW4gYGRpbGF0aW9uSGVpZ2h0ID09IGRpbGF0aW9uV2lkdGhgLiBJZiBpdCBpcyBncmVhdGVyIHRoYW5cbiAqICAgICAxLCB0aGVuIGFsbCB2YWx1ZXMgb2YgYHN0cmlkZXNgIG11c3QgYmUgMS5cbiAqIEBwYXJhbSBkYXRhRm9ybWF0OiBBbiBvcHRpb25hbCBzdHJpbmcgZnJvbTogXCJOSFdDXCIsIFwiTkNIV1wiLiBEZWZhdWx0cyB0b1xuICogICAgIFwiTkhXQ1wiLiBTcGVjaWZ5IHRoZSBkYXRhIGZvcm1hdCBvZiB0aGUgaW5wdXQgYW5kIG91dHB1dCBkYXRhLiBXaXRoIHRoZVxuICogICAgIGRlZmF1bHQgZm9ybWF0IFwiTkhXQ1wiLCB0aGUgZGF0YSBpcyBzdG9yZWQgaW4gdGhlIG9yZGVyIG9mOiBbYmF0Y2gsXG4gKiAgICAgaGVpZ2h0LCB3aWR0aCwgY2hhbm5lbHNdLiBPbmx5IFwiTkhXQ1wiIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0gZGltUm91bmRpbmdNb2RlIEEgc3RyaW5nIGZyb206ICdjZWlsJywgJ3JvdW5kJywgJ2Zsb29yJy4gSWYgbm9uZSBpc1xuICogICAgIHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gdHJ1bmNhdGUuXG4gKiBAcGFyYW0gYmlhcyBUZW5zb3IgdG8gYmUgYWRkZWQgdG8gdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSBhY3RpdmF0aW9uIE5hbWUgb2YgYWN0aXZhdGlvbiBrZXJuZWwgKGRlZmF1bHRzIHRvIGBsaW5lYXJgKS5cbiAqIEBwYXJhbSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzIFRlbnNvciBvZiBwcmVsdSB3ZWlnaHRzIHRvIGJlIGFwcGxpZWQgYXMgcGFydFxuICogICAgIG9mIGEgYHByZWx1YCBhY3RpdmF0aW9uLCB0eXBpY2FsbHkgdGhlIHNhbWUgc2hhcGUgYXMgYHhgLlxuICogQHBhcmFtIGxlYWt5cmVsdUFscGhhIE9wdGlvbmFsLiBBbHBoYSB0byBiZSBhcHBsaWVkIGFzIHBhcnQgb2YgYSBgbGVha3lyZWx1YFxuICogICAgIGFjdGl2YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZ1c2VkRGVwdGh3aXNlQ29udjJkXzxUIGV4dGVuZHMgVGVuc29yM0R8VGVuc29yNEQ+KHtcbiAgeCxcbiAgZmlsdGVyLFxuICBzdHJpZGVzLFxuICBwYWQsXG4gIGRhdGFGb3JtYXQgPSAnTkhXQycsXG4gIGRpbGF0aW9ucyA9IFsxLCAxXSxcbiAgZGltUm91bmRpbmdNb2RlLFxuICBiaWFzLFxuICBhY3RpdmF0aW9uID0gJ2xpbmVhcicsXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gIGxlYWt5cmVsdUFscGhhXG59OiB7XG4gIHg6IFR8VGVuc29yTGlrZSxcbiAgZmlsdGVyOiBUZW5zb3I0RHxUZW5zb3JMaWtlLFxuICBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXJdfG51bWJlcixcbiAgcGFkOiAndmFsaWQnfCdzYW1lJ3xudW1iZXIsXG4gIGRhdGFGb3JtYXQ/OiAnTkhXQyd8J05DSFcnLFxuICBkaWxhdGlvbnM/OiBbbnVtYmVyLCBudW1iZXJdfG51bWJlcixcbiAgZGltUm91bmRpbmdNb2RlPzogJ2Zsb29yJ3wncm91bmQnfCdjZWlsJyxcbiAgYmlhcz86IFRlbnNvcnxUZW5zb3JMaWtlLFxuICBhY3RpdmF0aW9uPzogQWN0aXZhdGlvbixcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz86IFRlbnNvcixcbiAgbGVha3lyZWx1QWxwaGE/OiBudW1iZXJcbn0pOiBUIHtcbiAgaWYgKHNob3VsZEZ1c2UoRU5HSU5FLnN0YXRlLmdyYWRpZW50RGVwdGgsIGFjdGl2YXRpb24pID09PSBmYWxzZSkge1xuICAgIGxldCByZXN1bHQgPSB1bmZ1c2VkRGVwdGh3aXNlQ29udjJkKFxuICAgICAgICB4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IGFkZChyZXN1bHQsIGJpYXMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBseUFjdGl2YXRpb24oXG4gICAgICAgICAgICAgICByZXN1bHQsIGFjdGl2YXRpb24sIHByZWx1QWN0aXZhdGlvbldlaWdodHMsIGxlYWt5cmVsdUFscGhhKSBhcyBUO1xuICB9XG5cbiAgY29uc3QgJHggPSBjb252ZXJ0VG9UZW5zb3IoeCwgJ3gnLCAnZGVwdGh3aXNlQ29udjJkJyk7XG4gIGNvbnN0ICRmaWx0ZXIgPSBjb252ZXJ0VG9UZW5zb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2RlcHRod2lzZUNvbnYyZCcpO1xuXG4gIGxldCB4NEQgPSAkeCBhcyBUZW5zb3I0RDtcbiAgbGV0IHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICBpZiAoJHgucmFuayA9PT0gMykge1xuICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgeDREID0gcmVzaGFwZSgkeCwgWzEsICR4LnNoYXBlWzBdLCAkeC5zaGFwZVsxXSwgJHguc2hhcGVbMl1dKTtcbiAgfVxuICB1dGlsLmFzc2VydChcbiAgICAgIHg0RC5yYW5rID09PSA0LFxuICAgICAgKCkgPT4gYEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgYHJhbmsgJHt4NEQucmFua30uYCk7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgJGZpbHRlci5yYW5rID09PSA0LFxuICAgICAgKCkgPT4gYEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBgICtcbiAgICAgICAgICBgYnV0IGdvdCByYW5rICR7JGZpbHRlci5yYW5rfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB4NEQuc2hhcGVbM10gPT09ICRmaWx0ZXIuc2hhcGVbMl0sXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgYCArXG4gICAgICAgICAgYCgke3g0RC5zaGFwZVszXX0pIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGAgK1xuICAgICAgICAgIGBmaWx0ZXIgJHskZmlsdGVyLnNoYXBlWzJdfS5gKTtcbiAgaWYgKGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgZGlsYXRpb25zID0gWzEsIDFdO1xuICB9XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgY29udl91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLFxuICAgICAgKCkgPT5cbiAgICAgICAgICAnRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCAnICtcbiAgICAgICAgICBgYmUgMS4gR290IHN0cmlkZXMgJHtzdHJpZGVzfSBhbmQgZGlsYXRpb25zICcke2RpbGF0aW9uc30nYCk7XG5cbiAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuaXNJbnQocGFkIGFzIG51bWJlciksXG4gICAgICAgICgpID0+IGBFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiBgICtcbiAgICAgICAgICAgIGB1c2luZyBkaW1Sb3VuZGluZ01vZGUgJHtkaW1Sb3VuZGluZ01vZGV9IGJ1dCBnb3QgcGFkICR7cGFkfS5gKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKFxuICAgICAgeDRELnNoYXBlLCAkZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLFxuICAgICAgdHJ1ZSAvKiBkZXB0aHdpc2UgKi8pO1xuXG4gIGxldCAkYmlhczogVGVuc29yO1xuICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgJGJpYXMgPSBjb252ZXJ0VG9UZW5zb3IoYmlhcywgJ2JpYXMnLCAnZnVzZWQgY29udjJkJyk7XG4gICAgWyRiaWFzXSA9IG1ha2VUeXBlc01hdGNoKCRiaWFzLCAkeCk7XG5cbiAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShjb252SW5mby5vdXRTaGFwZSwgJGJpYXMuc2hhcGUpO1xuICB9XG5cbiAgbGV0ICRwcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBUZW5zb3I7XG4gIGlmIChwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGwpIHtcbiAgICAkcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGNvbnZlcnRUb1RlbnNvcihcbiAgICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgJ3ByZWx1IHdlaWdodHMnLCAnZnVzZWQgZGVwdGh3aXNlQ29udjJkJyk7XG4gIH1cblxuICBjb25zdCBncmFkID0gKGR5OiBUZW5zb3I0RCwgc2F2ZWQ6IFRlbnNvcltdKSA9PiB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGNvbnZfdXRpbC50dXBsZVZhbHVlc0FyZU9uZShkaWxhdGlvbnMpLFxuICAgICAgICAoKSA9PiAnRXJyb3IgaW4gZ3JhZGllbnQgb2YgZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBkaWxhdGlvbiByYXRlcyAnICtcbiAgICAgICAgICAgIGBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgYCArXG4gICAgICAgICAgICBgJyR7ZGlsYXRpb25zfSdgKTtcbiAgICBjb25zdCBbJGZpbHRlciwgeDRELCB5LCBiaWFzXSA9IHNhdmVkO1xuXG4gICAgY29uc3QgZHlBY3RpdmF0aW9uID0gZ2V0RnVzZWREeUFjdGl2YXRpb24oZHksIHksIGFjdGl2YXRpb24pIGFzIFRlbnNvcjREO1xuXG4gICAgY29uc3QgeERlciA9IGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXQoXG4gICAgICAgICh4NEQgYXMgVGVuc29yNEQpLnNoYXBlLCBkeUFjdGl2YXRpb24sICRmaWx0ZXIgYXMgVGVuc29yNEQsIHN0cmlkZXMsXG4gICAgICAgIHBhZCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIGNvbnN0IGZpbHRlckRlciA9IGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyKFxuICAgICAgICB4NEQgYXMgVGVuc29yNEQsIGR5QWN0aXZhdGlvbiwgKCRmaWx0ZXIgYXMgVGVuc29yNEQpLnNoYXBlLCBzdHJpZGVzLFxuICAgICAgICBwYWQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcblxuICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGJpYXNEZXIgPSBnZXRGdXNlZEJpYXNHcmFkaWVudCgkYmlhcywgZHlBY3RpdmF0aW9uKTtcbiAgICAgIHJldHVybiBbeERlciwgZmlsdGVyRGVyLCBiaWFzRGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4RGVyLCBmaWx0ZXJEZXJdO1xuICB9O1xuXG4gIGNvbnN0IGlucHV0czogRnVzZWREZXB0aHdpc2VDb252MkRJbnB1dHMgPSB7XG4gICAgeDogeDRELFxuICAgIGZpbHRlcjogJGZpbHRlcixcbiAgICBiaWFzOiAkYmlhcyxcbiAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzOiAkcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1xuICB9O1xuICBjb25zdCBhdHRyczogRnVzZWREZXB0aHdpc2VDb252MkRBdHRycyA9IHtcbiAgICBzdHJpZGVzLFxuICAgIHBhZCxcbiAgICBkYXRhRm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBkaW1Sb3VuZGluZ01vZGUsXG4gICAgYWN0aXZhdGlvbixcbiAgICBsZWFreXJlbHVBbHBoYVxuICB9O1xuXG4gIC8vIERlcGVuZGluZyBvbiB0aGUgdGhlIHBhcmFtcyBwYXNzZWQgaW4gd2Ugd2lsbCBoYXZlIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgLy8gaW5wdXRzIGFuZCB0aHVzIGEgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBncmFkaWVudC5cbiAgaWYgKGJpYXMgPT0gbnVsbCkge1xuICAgIGNvbnN0IGN1c3RvbU9wID1cbiAgICAgICAgY3VzdG9tR3JhZCgoeDREOiBUZW5zb3I0RCwgZmlsdGVyOiBUZW5zb3I0RCwgc2F2ZTogR3JhZFNhdmVGdW5jKSA9PiB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgIGxldCByZXM6IFRlbnNvcjREfFRlbnNvcjNEID0gRU5HSU5FLnJ1bktlcm5lbChcbiAgICAgICAgICAgICAgRnVzZWREZXB0aHdpc2VDb252MkQsIGlucHV0cyBhcyB7fSBhcyBOYW1lZFRlbnNvck1hcCxcbiAgICAgICAgICAgICAgYXR0cnMgYXMge30gYXMgTmFtZWRBdHRyTWFwKTtcblxuICAgICAgICAgIHNhdmUoW2ZpbHRlciwgeDRELCByZXNdKTtcblxuICAgICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICAgIHJlcyA9IHJlc2hhcGUocmVzLCBbcmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXV0pIGFzXG4gICAgICAgICAgICAgICAgVGVuc29yM0Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt2YWx1ZTogcmVzLCBncmFkRnVuYzogZ3JhZH07XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBjdXN0b21PcCh4NEQsICRmaWx0ZXIpIGFzIFQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VzdG9tT3BXaXRoQmlhcyA9IGN1c3RvbUdyYWQoXG4gICAgICAgICh4NEQ6IFRlbnNvcjRELCBmaWx0ZXI6IFRlbnNvcjRELCBiaWFzOiBUZW5zb3IsIHNhdmU6IEdyYWRTYXZlRnVuYykgPT4ge1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBsZXQgcmVzOiBUZW5zb3I0RHxUZW5zb3IzRCA9IEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgIEZ1c2VkRGVwdGh3aXNlQ29udjJELCBpbnB1dHMgYXMge30gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgIGF0dHJzIGFzIHt9IGFzIE5hbWVkQXR0ck1hcCk7XG5cbiAgICAgICAgICBzYXZlKFtmaWx0ZXIsIHg0RCwgcmVzLCBiaWFzXSk7XG5cbiAgICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICByZXMgPSByZXNoYXBlKHJlcywgW3Jlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM11dKSBhc1xuICAgICAgICAgICAgICAgIFRlbnNvcjNEO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7dmFsdWU6IHJlcywgZ3JhZEZ1bmM6IGdyYWR9O1xuICAgICAgICB9KTtcblxuICAgIHJldHVybiBjdXN0b21PcFdpdGhCaWFzKHg0RCwgJGZpbHRlciwgJGJpYXMpIGFzIFQ7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBkZXB0aHdpc2VDb252MmQgPSBvcCh7ZnVzZWREZXB0aHdpc2VDb252MmRffSk7XG4iXX0=