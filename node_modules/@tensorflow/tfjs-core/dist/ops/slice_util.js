/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import * as util from '../util';
export function assertParamsValid(input, begin, size) {
    const inputRank = input.shape.length;
    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +
        `match the rank of the array (${inputRank}).`);
    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +
        `match the rank of the array (${inputRank}).`);
    for (let i = 0; i < inputRank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +
            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
    }
}
/** Converts a binary mask to an array of axes. Used in stridedSlice(). */
export function maskToAxes(mask) {
    const axes = [];
    let axis = 0;
    while (mask > 0) {
        if (mask & 1) {
            axes.push(axis);
        }
        mask /= 2;
        axis++;
    }
    return axes;
}
/** Computes the output shape given the strided slice params. */
export function computeOutShape(begin, end, strides) {
    const size = [];
    for (let axis = 0; axis < begin.length; axis++) {
        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
    }
    return size;
}
// Creates full selection at the elided dimensions. If the dimension matches
// the ellipsis mask, override the current stride value. Otherwise, insert.
export function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
    const newStrides = [...strides];
    for (let i = newStrides.length; i < inputShape.length; i++) {
        newStrides.push(1);
    }
    for (let i = 0; i < numElidedAxes; i++) {
        if (i === 0) {
            newStrides[ellipsisInsertionIndex] = 1;
        }
        else {
            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);
            newStrides.pop();
        }
    }
    return newStrides;
}
function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
    if (normalizedAxis <= ellipsisInsertionIndex) {
        return normalizedAxis;
    }
    return normalizedAxis - (numElidedAxes - 1);
}
function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
    const elidedAxes = [];
    for (let i = 0; i < numElidedAxes; i++) {
        elidedAxes.push(ellipsisInsertionIndex + i);
    }
    return elidedAxes;
}
// Normalize the start, end and strides.
export function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
    const inputRank = inputShape.length;
    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
    if (ellipsisAxes.length && numInterpolatedAxes > 0) {
        const fullIndex = ellipsisAxes[0];
        // The ellipsis applies to the masked index as well as any dimensions
        // that are interpolated.
        const numElidedAxes = numInterpolatedAxes + 1;
        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
        normalizedStrides =
            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
    }
    else {
        for (let axis = 0; axis < inputRank; axis++) {
            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
            normalizedEnd[axis] =
                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
        }
    }
    return {
        begin: normalizedBegin,
        end: normalizedEnd,
        strides: normalizedStrides
    };
}
// Creates full selection at the elided dimensions. If the dimension matches
// the ellipsis mask, override the current start value. Otherwise, insert.
export function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
            newIndices[axis] = 0;
        }
        else {
            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
            let originalValue = originalBegin[originalAxis];
            if (beginMask & 1 << originalAxis) {
                originalValue = 0;
            }
            newIndices[axis] = originalValue;
        }
    }
    return newIndices;
}
// Creates full selection at the elided dimensions. If the dimension matches
// the ellipsis mask, override the current stop value. Otherwise, insert.
export function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
            newIndices[axis] = Number.MAX_SAFE_INTEGER;
        }
        else {
            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
            let originalValue = originalEnd[originalAxis];
            if (endMask & 1 << originalAxis) {
                originalValue = Number.MAX_SAFE_INTEGER;
            }
            newIndices[axis] = originalValue;
        }
    }
    for (let i = 0; i < newIndices.length; i++) {
        // Handle negative indices
        const axisSize = inputShape[i];
        if (newIndices[i] < 0) {
            newIndices[i] += axisSize;
        }
        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);
    }
    return newIndices;
}
export function stridesForAxis(strides, axis, ellipsisMask) {
    let stride = strides[axis];
    if (ellipsisMask & (1 << axis) || stride == null) {
        stride = 1;
    }
    return stride;
}
export function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
    // Begin with the specified index
    let start = startIndices[axis];
    const stride = strides[axis] || 1;
    // Check the axis bit from right of masked axes, or the begin index is not set
    // for the axis.
    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
        if (stride > 0) {
            // Forward iteration - use the first element. These values will get
            // clamped below (Note: We could have set them to 0 and axis_size-1, but
            // use lowest() and max() to maintain symmetry with StopForAxis())
            start = Number.MIN_SAFE_INTEGER;
        }
        else {
            // Backward iteration - use the last element.
            start = Number.MAX_SAFE_INTEGER;
        }
    }
    // Handle negative indices
    const axisSize = inputShape[axis];
    if (start < 0) {
        start += axisSize;
    }
    // Clamping
    start = util.clamp(0, start, axisSize - 1);
    return start;
}
export function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
    // Begin with the specified index
    let stop = stopIndices[axis];
    const stride = strides[axis] || 1;
    // Check the axis bit from right of masked axes, or if the stop index is not
    // set for this axis.
    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {
        if (stride > 0) {
            // Forward iteration - use the last element. These values will get
            // clamped below
            stop = Number.MAX_SAFE_INTEGER;
        }
        else {
            // Backward iteration - use the first element.
            stop = Number.MIN_SAFE_INTEGER;
        }
    }
    // Handle negative indices
    const axisSize = inputShape[axis];
    if (stop < 0) {
        stop += axisSize;
    }
    // Clamping
    // Because the end index points one past the last element, we need slightly
    // different clamping ranges depending on the direction.
    if (stride > 0) {
        // Forward iteration
        stop = util.clamp(0, stop, axisSize);
    }
    else {
        // Backward iteration
        stop = util.clamp(-1, stop, axisSize - 1);
    }
    return stop;
}
/**
 * Returns true if the slice occupies a continous set of elements in the
 * 'flat' space.
 */
export function isSliceContinous(shape, begin, size) {
    // Index of the first axis that has size > 1.
    let firstNonOneAxis = size.length;
    for (let i = 0; i < size.length; i++) {
        if (size[i] > 1) {
            firstNonOneAxis = i;
            break;
        }
    }
    for (let i = firstNonOneAxis + 1; i < size.length; i++) {
        if (begin[i] > 0 || size[i] !== shape[i]) {
            return false;
        }
    }
    return true;
}
export function computeFlatOffset(begin, strides) {
    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
    for (let i = 0; i < begin.length - 1; i++) {
        flatOffset += begin[i] * strides[i];
    }
    return flatOffset;
}
export function parseSliceParams(x, begin, size) {
    // The following logic allows for more ergonomic calls.
    let begin_;
    const xRank = x.shape.length;
    if (typeof begin === 'number') {
        begin_ = [begin, ...new Array(xRank - 1).fill(0)];
    }
    else if (begin.length < xRank) {
        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
    }
    else {
        begin_ = begin.slice();
    }
    begin_.forEach(d => {
        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');
    });
    let size_;
    if (size == null) {
        size_ = new Array(xRank).fill(-1);
    }
    else if (typeof size === 'number') {
        size_ = [size, ...new Array(xRank - 1).fill(-1)];
    }
    else if (size.length < xRank) {
        size_ = size.concat(new Array(xRank - size.length).fill(-1));
    }
    else {
        size_ = size;
    }
    size_ = size_.map((d, i) => {
        if (d >= 0) {
            return d;
        }
        else {
            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +
                `${d} for the slice() size at index ${i}.`);
            return x.shape[i] - begin_[i];
        }
    });
    return [begin_, size_];
}
export function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    // make a copy because it may be modified further down.
    let $begin = begin.slice();
    let $end = end.slice();
    let $strides = strides;
    if (strides == null) {
        $strides = new Array($begin.length);
    }
    const ellipsisAxes = maskToAxes(ellipsisMask);
    if (ellipsisAxes.length > 1) {
        throw new Error('Multiple ellipses in slice is not allowed.');
    }
    if (ellipsisMask !== 0 && newAxisMask !== 0) {
        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');
    }
    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');
    }
    const numInterpolatedAxes = xShape.length - $begin.length;
    // Expand the dims of x based on the newAxisMask.
    const expandAxes = maskToAxes(newAxisMask);
    const newShape = xShape.slice();
    expandAxes.forEach(axis => {
        $begin[axis] = 0;
        $end[axis] = 1;
        newShape.splice(axis, 0, 1);
    });
    const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);
    $begin = normalizedBegin;
    $end = normalizedEnd;
    $strides = normalizedStrides;
    const shrinkAxes = maskToAxes(shrinkAxisMask);
    // Adjust the ends based on the shrink mask.
    shrinkAxes.forEach(axis => {
        $end[axis] = $begin[axis] + 1;
        $strides[axis] = 1;
    });
    // Figure out the output shape.
    const size = computeOutShape($begin, $end, $strides);
    // Remove the axes based on shrinkMask.
    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);
    const nonStrided = $strides.every(v => v === 1);
    return { nonStrided, $begin, $end, $strides, size, newShape, outShape };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpY2VfdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NsaWNlX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxLQUFLLElBQUksTUFBTSxTQUFTLENBQUM7QUFZaEMsTUFBTSxVQUFVLGlCQUFpQixDQUM3QixLQUFpQixFQUFFLEtBQWUsRUFBRSxJQUFjO0lBQ3BELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3JDLElBQUksQ0FBQyxNQUFNLENBQ1AsU0FBUyxLQUFLLEtBQUssQ0FBQyxNQUFNLEVBQzFCLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixTQUFTLHNCQUFzQixLQUFLLFFBQVE7UUFDL0QsZ0NBQWdDLFNBQVMsSUFBSSxDQUFDLENBQUM7SUFDdkQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxTQUFTLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFDekIsR0FBRyxFQUFFLENBQUMsaUJBQWlCLFNBQVMscUJBQXFCLElBQUksUUFBUTtRQUM3RCxnQ0FBZ0MsU0FBUyxJQUFJLENBQUMsQ0FBQztJQUV2RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQ2xDLElBQUksQ0FBQyxNQUFNLENBQ1AsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUNwQyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsU0FBUyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUk7WUFDMUQsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQyxNQUNqRCxLQUFLLENBQUMsS0FBSyxDQUFD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QVUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxDQUFDO0FBQ3hFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29ySW5mb30gZnJvbSAnLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCB0eXBlIFNsaWNlSW5mbyA9IHtcbiAgbm9uU3RyaWRlZDogYm9vbGVhbixcbiAgJGJlZ2luOiBudW1iZXJbXSxcbiAgJGVuZDogbnVtYmVyW10sXG4gICRzdHJpZGVzOiBudW1iZXJbXSxcbiAgc2l6ZTogbnVtYmVyW10sXG4gIG5ld1NoYXBlOiBudW1iZXJbXSxcbiAgb3V0U2hhcGU6IG51bWJlcltdXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UGFyYW1zVmFsaWQoXG4gICAgaW5wdXQ6IFRlbnNvckluZm8sIGJlZ2luOiBudW1iZXJbXSwgc2l6ZTogbnVtYmVyW10pOiB2b2lkIHtcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXQuc2hhcGUubGVuZ3RoO1xuICB1dGlsLmFzc2VydChcbiAgICAgIGlucHV0UmFuayA9PT0gYmVnaW4ubGVuZ3RoLFxuICAgICAgKCkgPT4gYEVycm9yIGluIHNsaWNlJHtpbnB1dFJhbmt9RDogTGVuZ3RoIG9mIGJlZ2luICR7YmVnaW59IG11c3QgYCArXG4gICAgICAgICAgYG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoJHtpbnB1dFJhbmt9KS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICBpbnB1dFJhbmsgPT09IHNpemUubGVuZ3RoLFxuICAgICAgKCkgPT4gYEVycm9yIGluIHNsaWNlJHtpbnB1dFJhbmt9RDogTGVuZ3RoIG9mIHNpemUgJHtzaXplfSBtdXN0IGAgK1xuICAgICAgICAgIGBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKCR7aW5wdXRSYW5rfSkuYCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFJhbms7ICsraSkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBiZWdpbltpXSArIHNpemVbaV0gPD0gaW5wdXQuc2hhcGVbaV0sXG4gICAgICAgICgpID0+IGBFcnJvciBpbiBzbGljZSR7aW5wdXRSYW5rfUQ6IGJlZ2luWyR7aX1dICsgc2l6ZVske2l9XSBgICtcbiAgICAgICAgICAgIGAoJHtiZWdpbltpXSArIHNpemVbaV19KSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVske2l9XSAoJHtcbiAgICAgICAgICAgICAgICAgIGlucHV0LnNoYXBlW2ldfSlgKTtcbiAgfVxufVxuXG4vKiogQ29udmVydHMgYSBiaW5hcnkgbWFzayB0byBhbiBhcnJheSBvZiBheGVzLiBVc2VkIGluIHN0cmlkZWRTbGljZSgpLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2tUb0F4ZXMobWFzazogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBheGVzID0gW107XG4gIGxldCBheGlzID0gMDtcbiAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgaWYgKG1hc2sgJiAxKSB7XG4gICAgICBheGVzLnB1c2goYXhpcyk7XG4gICAgfVxuICAgIG1hc2sgLz0gMjtcbiAgICBheGlzKys7XG4gIH1cbiAgcmV0dXJuIGF4ZXM7XG59XG5cbi8qKiBDb21wdXRlcyB0aGUgb3V0cHV0IHNoYXBlIGdpdmVuIHRoZSBzdHJpZGVkIHNsaWNlIHBhcmFtcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoXG4gICAgYmVnaW46IG51bWJlcltdLCBlbmQ6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgY29uc3Qgc2l6ZSA9IFtdO1xuICBmb3IgKGxldCBheGlzID0gMDsgYXhpcyA8IGJlZ2luLmxlbmd0aDsgYXhpcysrKSB7XG4gICAgc2l6ZVtheGlzXSA9IE1hdGguY2VpbCgoZW5kW2F4aXNdIC0gYmVnaW5bYXhpc10pIC8gc3RyaWRlc1theGlzXSk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIENyZWF0ZXMgZnVsbCBzZWxlY3Rpb24gYXQgdGhlIGVsaWRlZCBkaW1lbnNpb25zLiBJZiB0aGUgZGltZW5zaW9uIG1hdGNoZXNcbi8vIHRoZSBlbGxpcHNpcyBtYXNrLCBvdmVycmlkZSB0aGUgY3VycmVudCBzdHJpZGUgdmFsdWUuIE90aGVyd2lzZSwgaW5zZXJ0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlkZXNXaXRoRWxpZGVkRGltcyhcbiAgICBzdHJpZGVzOiBudW1iZXJbXSwgZWxsaXBzaXNJbnNlcnRpb25JbmRleDogbnVtYmVyLCBudW1FbGlkZWRBeGVzOiBudW1iZXIsXG4gICAgaW5wdXRTaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IG5ld1N0cmlkZXMgPSBbLi4uc3RyaWRlc107XG4gIGZvciAobGV0IGkgPSBuZXdTdHJpZGVzLmxlbmd0aDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBuZXdTdHJpZGVzLnB1c2goMSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGlkZWRBeGVzOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbmV3U3RyaWRlc1tlbGxpcHNpc0luc2VydGlvbkluZGV4XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmlkZXMuc3BsaWNlKFxuICAgICAgICAgIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXgsIDAgLyogbnVtIGVsZW1lbnRzIHRvIGRlbGV0ZSAqLyxcbiAgICAgICAgICAxIC8qIGVsZW1lbnQgdG8gYWRkICovKTtcbiAgICAgIG5ld1N0cmlkZXMucG9wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTdHJpZGVzO1xufVxuXG5mdW5jdGlvbiB1bm5vcm1hbGl6ZUF4aXMoXG4gICAgZWxsaXBzaXNJbnNlcnRpb25JbmRleDogbnVtYmVyLCBudW1FbGlkZWRBeGVzOiBudW1iZXIsXG4gICAgbm9ybWFsaXplZEF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChub3JtYWxpemVkQXhpcyA8PSBlbGxpcHNpc0luc2VydGlvbkluZGV4KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRBeGlzO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRBeGlzIC0gKG51bUVsaWRlZEF4ZXMgLSAxKTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxpZGVkQXhlcyhudW1FbGlkZWRBeGVzOiBudW1iZXIsIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXg6IG51bWJlcikge1xuICBjb25zdCBlbGlkZWRBeGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxpZGVkQXhlczsgaSsrKSB7XG4gICAgZWxpZGVkQXhlcy5wdXNoKGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXggKyBpKTtcbiAgfVxuICByZXR1cm4gZWxpZGVkQXhlcztcbn1cblxuLy8gTm9ybWFsaXplIHRoZSBzdGFydCwgZW5kIGFuZCBzdHJpZGVzLlxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRBeGVzKFxuICAgIGlucHV0U2hhcGU6IG51bWJlcltdLCBlbGxpcHNpc0F4ZXM6IG51bWJlcltdLCBudW1JbnRlcnBvbGF0ZWRBeGVzOiBudW1iZXIsXG4gICAgYmVnaW46IG51bWJlcltdLCBlbmQ6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgYmVnaW5NYXNrOiBudW1iZXIsXG4gICAgZW5kTWFzazogbnVtYmVyLFxuICAgIGVsbGlwc2lzTWFzazogbnVtYmVyKToge2JlZ2luOiBudW1iZXJbXSwgZW5kOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW119IHtcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGxldCBub3JtYWxpemVkQmVnaW4gPSBuZXcgQXJyYXkoaW5wdXRSYW5rKSxcbiAgICAgIG5vcm1hbGl6ZWRFbmQgPSBuZXcgQXJyYXkoaW5wdXRSYW5rKSxcbiAgICAgIG5vcm1hbGl6ZWRTdHJpZGVzID0gbmV3IEFycmF5KGlucHV0UmFuayk7XG4gIGlmIChlbGxpcHNpc0F4ZXMubGVuZ3RoICYmIG51bUludGVycG9sYXRlZEF4ZXMgPiAwKSB7XG4gICAgY29uc3QgZnVsbEluZGV4ID0gZWxsaXBzaXNBeGVzWzBdO1xuXG4gICAgLy8gVGhlIGVsbGlwc2lzIGFwcGxpZXMgdG8gdGhlIG1hc2tlZCBpbmRleCBhcyB3ZWxsIGFzIGFueSBkaW1lbnNpb25zXG4gICAgLy8gdGhhdCBhcmUgaW50ZXJwb2xhdGVkLlxuICAgIGNvbnN0IG51bUVsaWRlZEF4ZXMgPSBudW1JbnRlcnBvbGF0ZWRBeGVzICsgMTtcbiAgICBub3JtYWxpemVkQmVnaW4gPSBzdGFydEluZGljZXNXaXRoRWxpZGVkRGltcyhcbiAgICAgICAgYmVnaW5NYXNrLCBmdWxsSW5kZXgsIG51bUVsaWRlZEF4ZXMsIGJlZ2luLCBpbnB1dFNoYXBlKTtcbiAgICBub3JtYWxpemVkRW5kID0gc3RvcEluZGljZXNXaXRoRWxpZGVkRGltcyhcbiAgICAgICAgZW5kTWFzaywgZnVsbEluZGV4LCBudW1FbGlkZWRBeGVzLCBlbmQsIGlucHV0U2hhcGUpO1xuICAgIG5vcm1hbGl6ZWRTdHJpZGVzID1cbiAgICAgICAgc3RyaWRlc1dpdGhFbGlkZWREaW1zKHN0cmlkZXMsIGZ1bGxJbmRleCwgbnVtRWxpZGVkQXhlcywgaW5wdXRTaGFwZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgYXhpcyA9IDA7IGF4aXMgPCBpbnB1dFJhbms7IGF4aXMrKykge1xuICAgICAgbm9ybWFsaXplZEJlZ2luW2F4aXNdID0gc3RhcnRGb3JBeGlzKFxuICAgICAgICAgIGJlZ2luTWFzaywgYmVnaW4sIHN0cmlkZXMsIGlucHV0U2hhcGUsIGF4aXMsIGVsbGlwc2lzTWFzayk7XG4gICAgICBub3JtYWxpemVkRW5kW2F4aXNdID1cbiAgICAgICAgICBzdG9wRm9yQXhpcyhlbmRNYXNrLCBlbmQsIHN0cmlkZXMsIGlucHV0U2hhcGUsIGF4aXMsIGVsbGlwc2lzTWFzayk7XG4gICAgICBub3JtYWxpemVkU3RyaWRlc1theGlzXSA9IHN0cmlkZXNGb3JBeGlzKHN0cmlkZXMsIGF4aXMsIGVsbGlwc2lzTWFzayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbjogbm9ybWFsaXplZEJlZ2luLFxuICAgIGVuZDogbm9ybWFsaXplZEVuZCxcbiAgICBzdHJpZGVzOiBub3JtYWxpemVkU3RyaWRlc1xuICB9O1xufVxuXG4vLyBDcmVhdGVzIGZ1bGwgc2VsZWN0aW9uIGF0IHRoZSBlbGlkZWQgZGltZW5zaW9ucy4gSWYgdGhlIGRpbWVuc2lvbiBtYXRjaGVzXG4vLyB0aGUgZWxsaXBzaXMgbWFzaywgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgc3RhcnQgdmFsdWUuIE90aGVyd2lzZSwgaW5zZXJ0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SW5kaWNlc1dpdGhFbGlkZWREaW1zKFxuICAgIGJlZ2luTWFzazogbnVtYmVyLCBlbGxpcHNpc0luc2VydGlvbkluZGV4OiBudW1iZXIsIG51bUVsaWRlZEF4ZXM6IG51bWJlcixcbiAgICBvcmlnaW5hbEJlZ2luOiBudW1iZXJbXSwgaW5wdXRTaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbLi4uaW5wdXRTaGFwZV07XG4gIGNvbnN0IGVsaWRlZEF4ZXMgPSBnZXRFbGlkZWRBeGVzKG51bUVsaWRlZEF4ZXMsIGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXgpO1xuXG4gIGZvciAobGV0IGF4aXMgPSAwOyBheGlzIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGF4aXMrKykge1xuICAgIGlmIChlbGlkZWRBeGVzLmluZGV4T2YoYXhpcykgPiAtMSkge1xuICAgICAgbmV3SW5kaWNlc1theGlzXSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQXhpcyA9XG4gICAgICAgICAgdW5ub3JtYWxpemVBeGlzKGVsbGlwc2lzSW5zZXJ0aW9uSW5kZXgsIG51bUVsaWRlZEF4ZXMsIGF4aXMpO1xuICAgICAgbGV0IG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbEJlZ2luW29yaWdpbmFsQXhpc107XG4gICAgICBpZiAoYmVnaW5NYXNrICYgMSA8PCBvcmlnaW5hbEF4aXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG5ld0luZGljZXNbYXhpc10gPSBvcmlnaW5hbFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3SW5kaWNlcztcbn1cblxuLy8gQ3JlYXRlcyBmdWxsIHNlbGVjdGlvbiBhdCB0aGUgZWxpZGVkIGRpbWVuc2lvbnMuIElmIHRoZSBkaW1lbnNpb24gbWF0Y2hlc1xuLy8gdGhlIGVsbGlwc2lzIG1hc2ssIG92ZXJyaWRlIHRoZSBjdXJyZW50IHN0b3AgdmFsdWUuIE90aGVyd2lzZSwgaW5zZXJ0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbmRpY2VzV2l0aEVsaWRlZERpbXMoXG4gICAgZW5kTWFzazogbnVtYmVyLCBlbGxpcHNpc0luc2VydGlvbkluZGV4OiBudW1iZXIsIG51bUVsaWRlZEF4ZXM6IG51bWJlcixcbiAgICBvcmlnaW5hbEVuZDogbnVtYmVyW10sIGlucHV0U2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCBuZXdJbmRpY2VzID0gWy4uLmlucHV0U2hhcGVdO1xuICBjb25zdCBlbGlkZWRBeGVzID0gZ2V0RWxpZGVkQXhlcyhudW1FbGlkZWRBeGVzLCBlbGxpcHNpc0luc2VydGlvbkluZGV4KTtcblxuICBmb3IgKGxldCBheGlzID0gMDsgYXhpcyA8IG5ld0luZGljZXMubGVuZ3RoOyBheGlzKyspIHtcbiAgICBpZiAoZWxpZGVkQXhlcy5pbmRleE9mKGF4aXMpID4gLTEpIHtcbiAgICAgIG5ld0luZGljZXNbYXhpc10gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ2luYWxBeGlzID1cbiAgICAgICAgICB1bm5vcm1hbGl6ZUF4aXMoZWxsaXBzaXNJbnNlcnRpb25JbmRleCwgbnVtRWxpZGVkQXhlcywgYXhpcyk7XG4gICAgICBsZXQgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsRW5kW29yaWdpbmFsQXhpc107XG4gICAgICBpZiAoZW5kTWFzayAmIDEgPDwgb3JpZ2luYWxBeGlzKSB7XG4gICAgICAgIG9yaWdpbmFsVmFsdWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIG5ld0luZGljZXNbYXhpc10gPSBvcmlnaW5hbFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgY29uc3QgYXhpc1NpemUgPSBpbnB1dFNoYXBlW2ldO1xuICAgIGlmIChuZXdJbmRpY2VzW2ldIDwgMCkge1xuICAgICAgbmV3SW5kaWNlc1tpXSArPSBheGlzU2l6ZTtcbiAgICB9XG4gICAgbmV3SW5kaWNlc1tpXSA9IHV0aWwuY2xhbXAoMCwgbmV3SW5kaWNlc1tpXSwgaW5wdXRTaGFwZVtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0luZGljZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpZGVzRm9yQXhpcyhcbiAgICBzdHJpZGVzOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBlbGxpcHNpc01hc2s6IG51bWJlcik6IG51bWJlciB7XG4gIGxldCBzdHJpZGUgPSBzdHJpZGVzW2F4aXNdO1xuICBpZiAoZWxsaXBzaXNNYXNrICYgKDEgPDwgYXhpcykgfHwgc3RyaWRlID09IG51bGwpIHtcbiAgICBzdHJpZGUgPSAxO1xuICB9XG5cbiAgcmV0dXJuIHN0cmlkZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Rm9yQXhpcyhcbiAgICBiZWdpbk1hc2s6IG51bWJlciwgc3RhcnRJbmRpY2VzOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sXG4gICAgaW5wdXRTaGFwZTogbnVtYmVyW10sIGF4aXM6IG51bWJlciwgZWxsaXBzaXNNYXNrOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBCZWdpbiB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgbGV0IHN0YXJ0ID0gc3RhcnRJbmRpY2VzW2F4aXNdO1xuICBjb25zdCBzdHJpZGUgPSBzdHJpZGVzW2F4aXNdIHx8IDE7XG5cbiAgLy8gQ2hlY2sgdGhlIGF4aXMgYml0IGZyb20gcmlnaHQgb2YgbWFza2VkIGF4ZXMsIG9yIHRoZSBiZWdpbiBpbmRleCBpcyBub3Qgc2V0XG4gIC8vIGZvciB0aGUgYXhpcy5cbiAgaWYgKGJlZ2luTWFzayAmIDEgPDwgYXhpcyB8fCBlbGxpcHNpc01hc2sgJiAxIDw8IGF4aXMgfHwgc3RhcnQgPT0gbnVsbCkge1xuICAgIGlmIChzdHJpZGUgPiAwKSB7XG4gICAgICAvLyBGb3J3YXJkIGl0ZXJhdGlvbiAtIHVzZSB0aGUgZmlyc3QgZWxlbWVudC4gVGhlc2UgdmFsdWVzIHdpbGwgZ2V0XG4gICAgICAvLyBjbGFtcGVkIGJlbG93IChOb3RlOiBXZSBjb3VsZCBoYXZlIHNldCB0aGVtIHRvIDAgYW5kIGF4aXNfc2l6ZS0xLCBidXRcbiAgICAgIC8vIHVzZSBsb3dlc3QoKSBhbmQgbWF4KCkgdG8gbWFpbnRhaW4gc3ltbWV0cnkgd2l0aCBTdG9wRm9yQXhpcygpKVxuICAgICAgc3RhcnQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmFja3dhcmQgaXRlcmF0aW9uIC0gdXNlIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICBzdGFydCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gIGNvbnN0IGF4aXNTaXplID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGF4aXNTaXplO1xuICB9XG5cbiAgLy8gQ2xhbXBpbmdcbiAgc3RhcnQgPSB1dGlsLmNsYW1wKDAsIHN0YXJ0LCBheGlzU2l6ZSAtIDEpO1xuXG4gIHJldHVybiBzdGFydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BGb3JBeGlzKFxuICAgIGVuZE1hc2s6IG51bWJlciwgc3RvcEluZGljZXM6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICBpbnB1dFNoYXBlOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBlbGxpcHNpc01hc2s6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIEJlZ2luIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleFxuICBsZXQgc3RvcCA9IHN0b3BJbmRpY2VzW2F4aXNdO1xuICBjb25zdCBzdHJpZGUgPSBzdHJpZGVzW2F4aXNdIHx8IDE7XG5cbiAgLy8gQ2hlY2sgdGhlIGF4aXMgYml0IGZyb20gcmlnaHQgb2YgbWFza2VkIGF4ZXMsIG9yIGlmIHRoZSBzdG9wIGluZGV4IGlzIG5vdFxuICAvLyBzZXQgZm9yIHRoaXMgYXhpcy5cbiAgaWYgKGVuZE1hc2sgJiAoMSA8PCBheGlzKSB8fCBlbGxpcHNpc01hc2sgJiAoMSA8PCBheGlzKSB8fCBzdG9wID09IG51bGwpIHtcbiAgICBpZiAoc3RyaWRlID4gMCkge1xuICAgICAgLy8gRm9yd2FyZCBpdGVyYXRpb24gLSB1c2UgdGhlIGxhc3QgZWxlbWVudC4gVGhlc2UgdmFsdWVzIHdpbGwgZ2V0XG4gICAgICAvLyBjbGFtcGVkIGJlbG93XG4gICAgICBzdG9wID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJhY2t3YXJkIGl0ZXJhdGlvbiAtIHVzZSB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgIHN0b3AgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICBjb25zdCBheGlzU2l6ZSA9IGlucHV0U2hhcGVbYXhpc107XG4gIGlmIChzdG9wIDwgMCkge1xuICAgIHN0b3AgKz0gYXhpc1NpemU7XG4gIH1cblxuICAvLyBDbGFtcGluZ1xuICAvLyBCZWNhdXNlIHRoZSBlbmQgaW5kZXggcG9pbnRzIG9uZSBwYXN0IHRoZSBsYXN0IGVsZW1lbnQsIHdlIG5lZWQgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGNsYW1waW5nIHJhbmdlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbi5cbiAgaWYgKHN0cmlkZSA+IDApIHtcbiAgICAvLyBGb3J3YXJkIGl0ZXJhdGlvblxuICAgIHN0b3AgPSB1dGlsLmNsYW1wKDAsIHN0b3AsIGF4aXNTaXplKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCYWNrd2FyZCBpdGVyYXRpb25cbiAgICBzdG9wID0gdXRpbC5jbGFtcCgtMSwgc3RvcCwgYXhpc1NpemUgLSAxKTtcbiAgfVxuXG4gIHJldHVybiBzdG9wO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2xpY2Ugb2NjdXBpZXMgYSBjb250aW5vdXMgc2V0IG9mIGVsZW1lbnRzIGluIHRoZVxuICogJ2ZsYXQnIHNwYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTbGljZUNvbnRpbm91cyhcbiAgICBzaGFwZTogbnVtYmVyW10sIGJlZ2luOiBudW1iZXJbXSwgc2l6ZTogbnVtYmVyW10pIHtcbiAgLy8gSW5kZXggb2YgdGhlIGZpcnN0IGF4aXMgdGhhdCBoYXMgc2l6ZSA+IDEuXG4gIGxldCBmaXJzdE5vbk9uZUF4aXMgPSBzaXplLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNpemVbaV0gPiAxKSB7XG4gICAgICBmaXJzdE5vbk9uZUF4aXMgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IGZpcnN0Tm9uT25lQXhpcyArIDE7IGkgPCBzaXplLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJlZ2luW2ldID4gMCB8fCBzaXplW2ldICE9PSBzaGFwZVtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVGbGF0T2Zmc2V0KGJlZ2luOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgZmxhdE9mZnNldCA9IGJlZ2luLmxlbmd0aCA+IDAgPyBiZWdpbltiZWdpbi5sZW5ndGggLSAxXSA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmVnaW4ubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgZmxhdE9mZnNldCArPSBiZWdpbltpXSAqIHN0cmlkZXNbaV07XG4gIH1cbiAgcmV0dXJuIGZsYXRPZmZzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNsaWNlUGFyYW1zKFxuICAgIHg6IFRlbnNvckluZm8sIGJlZ2luOiBudW1iZXJ8bnVtYmVyW10sIHNpemU/OiBudW1iZXJ8bnVtYmVyW10pIHtcbiAgLy8gVGhlIGZvbGxvd2luZyBsb2dpYyBhbGxvd3MgZm9yIG1vcmUgZXJnb25vbWljIGNhbGxzLlxuICBsZXQgYmVnaW5fOiBudW1iZXJbXTtcbiAgY29uc3QgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ251bWJlcicpIHtcbiAgICBiZWdpbl8gPSBbYmVnaW4sIC4uLm5ldyBBcnJheSh4UmFuayAtIDEpLmZpbGwoMCldO1xuICB9IGVsc2UgaWYgKGJlZ2luLmxlbmd0aCA8IHhSYW5rKSB7XG4gICAgYmVnaW5fID0gYmVnaW4uY29uY2F0KG5ldyBBcnJheSh4UmFuayAtIGJlZ2luLmxlbmd0aCkuZmlsbCgwKSk7XG4gIH0gZWxzZSB7XG4gICAgYmVnaW5fID0gYmVnaW4uc2xpY2UoKTtcbiAgfVxuICBiZWdpbl8uZm9yRWFjaChkID0+IHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZCAhPT0gLTEsICgpID0+ICdzbGljZSgpIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgYmVnaW4gaW5kZXhpbmcuJyk7XG4gIH0pO1xuICBsZXQgc2l6ZV86IG51bWJlcltdO1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgc2l6ZV8gPSBuZXcgQXJyYXkoeFJhbmspLmZpbGwoLTEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgIHNpemVfID0gW3NpemUsIC4uLm5ldyBBcnJheSh4UmFuayAtIDEpLmZpbGwoLTEpXTtcbiAgfSBlbHNlIGlmIChzaXplLmxlbmd0aCA8IHhSYW5rKSB7XG4gICAgc2l6ZV8gPSBzaXplLmNvbmNhdChuZXcgQXJyYXkoeFJhbmsgLSBzaXplLmxlbmd0aCkuZmlsbCgtMSkpO1xuICB9IGVsc2Uge1xuICAgIHNpemVfID0gc2l6ZTtcbiAgfVxuICBzaXplXyA9IHNpemVfLm1hcCgoZCwgaSkgPT4ge1xuICAgIGlmIChkID49IDApIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBkID09PSAtMSxcbiAgICAgICAgICAoKSA9PiBgTmVnYXRpdmUgc2l6ZSB2YWx1ZXMgc2hvdWxkIGJlIGV4YWN0bHkgLTEgYnV0IGdvdCBgICtcbiAgICAgICAgICAgICAgYCR7ZH0gZm9yIHRoZSBzbGljZSgpIHNpemUgYXQgaW5kZXggJHtpfS5gKTtcbiAgICAgIHJldHVybiB4LnNoYXBlW2ldIC0gYmVnaW5fW2ldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbYmVnaW5fLCBzaXplX107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUluZm8oXG4gICAgeFNoYXBlOiBudW1iZXJbXSwgYmVnaW46IG51bWJlcltdLCBlbmQ6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICBiZWdpbk1hc2s6IG51bWJlciwgZW5kTWFzazogbnVtYmVyLCBlbGxpcHNpc01hc2s6IG51bWJlcixcbiAgICBuZXdBeGlzTWFzazogbnVtYmVyLCBzaHJpbmtBeGlzTWFzazogbnVtYmVyKTogU2xpY2VJbmZvIHtcbiAgLy8gbWFrZSBhIGNvcHkgYmVjYXVzZSBpdCBtYXkgYmUgbW9kaWZpZWQgZnVydGhlciBkb3duLlxuICBsZXQgJGJlZ2luID0gYmVnaW4uc2xpY2UoKTtcbiAgbGV0ICRlbmQgPSBlbmQuc2xpY2UoKTtcbiAgbGV0ICRzdHJpZGVzID0gc3RyaWRlcztcblxuICBpZiAoc3RyaWRlcyA9PSBudWxsKSB7XG4gICAgJHN0cmlkZXMgPSBuZXcgQXJyYXkoJGJlZ2luLmxlbmd0aCk7XG4gIH1cblxuICBjb25zdCBlbGxpcHNpc0F4ZXMgPSBtYXNrVG9BeGVzKGVsbGlwc2lzTWFzayk7XG4gIGlmIChlbGxpcHNpc0F4ZXMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgZWxsaXBzZXMgaW4gc2xpY2UgaXMgbm90IGFsbG93ZWQuJyk7XG4gIH1cblxuICBpZiAoZWxsaXBzaXNNYXNrICE9PSAwICYmIG5ld0F4aXNNYXNrICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVXNpbmcgYm90aCBlbGxpcHNpc01hc2sgYW5kIG5ld0F4aXNNYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYgKGVsbGlwc2lzTWFzayAhPT0gMCAmJiBzaHJpbmtBeGlzTWFzayAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VzaW5nIGJvdGggZWxsaXBzaXNNYXNrIGFuZCBzaHJpbmtBeGlzTWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIGNvbnN0IG51bUludGVycG9sYXRlZEF4ZXMgPSB4U2hhcGUubGVuZ3RoIC0gJGJlZ2luLmxlbmd0aDtcblxuICAvLyBFeHBhbmQgdGhlIGRpbXMgb2YgeCBiYXNlZCBvbiB0aGUgbmV3QXhpc01hc2suXG4gIGNvbnN0IGV4cGFuZEF4ZXMgPSBtYXNrVG9BeGVzKG5ld0F4aXNNYXNrKTtcbiAgY29uc3QgbmV3U2hhcGUgPSB4U2hhcGUuc2xpY2UoKTtcbiAgZXhwYW5kQXhlcy5mb3JFYWNoKGF4aXMgPT4ge1xuICAgICRiZWdpbltheGlzXSA9IDA7XG4gICAgJGVuZFtheGlzXSA9IDE7XG4gICAgbmV3U2hhcGUuc3BsaWNlKGF4aXMsIDAsIDEpO1xuICB9KTtcblxuICBjb25zdCB7XG4gICAgYmVnaW46IG5vcm1hbGl6ZWRCZWdpbixcbiAgICBlbmQ6IG5vcm1hbGl6ZWRFbmQsXG4gICAgc3RyaWRlczogbm9ybWFsaXplZFN0cmlkZXNcbiAgfSA9XG4gICAgICBnZXROb3JtYWxpemVkQXhlcyhcbiAgICAgICAgICBuZXdTaGFwZSwgZWxsaXBzaXNBeGVzLCBudW1JbnRlcnBvbGF0ZWRBeGVzLCAkYmVnaW4sICRlbmQsICRzdHJpZGVzLFxuICAgICAgICAgIGJlZ2luTWFzaywgZW5kTWFzaywgZWxsaXBzaXNNYXNrKTtcbiAgJGJlZ2luID0gbm9ybWFsaXplZEJlZ2luO1xuICAkZW5kID0gbm9ybWFsaXplZEVuZDtcbiAgJHN0cmlkZXMgPSBub3JtYWxpemVkU3RyaWRlcztcblxuICBjb25zdCBzaHJpbmtBeGVzID0gbWFza1RvQXhlcyhzaHJpbmtBeGlzTWFzayk7XG4gIC8vIEFkanVzdCB0aGUgZW5kcyBiYXNlZCBvbiB0aGUgc2hyaW5rIG1hc2suXG4gIHNocmlua0F4ZXMuZm9yRWFjaChheGlzID0+IHtcbiAgICAkZW5kW2F4aXNdID0gJGJlZ2luW2F4aXNdICsgMTtcbiAgICAkc3RyaWRlc1theGlzXSA9IDE7XG4gIH0pO1xuXG4gIC8vIEZpZ3VyZSBvdXQgdGhlIG91dHB1dCBzaGFwZS5cbiAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVPdXRTaGFwZSgkYmVnaW4sICRlbmQsICRzdHJpZGVzKTtcbiAgLy8gUmVtb3ZlIHRoZSBheGVzIGJhc2VkIG9uIHNocmlua01hc2suXG4gIGNvbnN0IG91dFNoYXBlID0gc2l6ZS5maWx0ZXIoKF8sIGF4aXMpID0+IHNocmlua0F4ZXMuaW5kZXhPZihheGlzKSA9PT0gLTEpO1xuXG4gIGNvbnN0IG5vblN0cmlkZWQgPSAkc3RyaWRlcy5ldmVyeSh2ID0+IHYgPT09IDEpO1xuXG4gIHJldHVybiB7bm9uU3RyaWRlZCwgJGJlZ2luLCAkZW5kLCAkc3RyaWRlcywgc2l6ZSwgbmV3U2hhcGUsIG91dFNoYXBlfTtcbn1cbiJdfQ==